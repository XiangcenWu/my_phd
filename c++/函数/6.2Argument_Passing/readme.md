# Section 6.2 Argument Passing

## argument and parameter 实参与形参
parameter(形参)，argument(实参)。

看下面这段代码
```python
def add(x, y):
    return x + y
```

x, y ,就是函数add的形参，形参这个概念，侧重于函数的定义，这段代码里，没有实参，因为实参侧重于函数的调用，看下面这段代码
```python
def add(x, y):
    return x + y
​
add(3, 4)
```
3 和 4 就是调用函数add时传入的实参，这句话强调了调用函数和传入两个动作，只有当这两个动作发生时，才有实参的概念，或者说，实参的概念才有意义。

那么，return x + y 这行代码里，x 与 y 是实参，还是形参呢？ 我个人的见解是，在函数里再去辨别他们已经没什么意义，如果一定需要一个答案，那么，我认为它们是形参，而不是实参。实参，是一个只在函数调用时存在的概念，具体到函数内部执行时，我们已经不关心实参这个事情了。

parameter(形参)，argument(实参)。为什么要有形参和实参这两个概念呢？形参，规定了函数的样式，是一种形式的约定，强类型语言还会约定一个形参的类型。实参，是实际调用时传入函数的数据，因此叫实参。

实参与形参，是两个维度的事物，一个强调形式，一个强调实际数值，因此我说，他们是两个维度的事物，形参是静态的概念，实参是动态的概念，我执行add(3, 5)， 函数的实参就是3, 5。下一次执行add(7, 8)，那么函数的实参就是7和8，但形参始终都是x和y。

在函数内，形参的值，是由实参决定的，在函数执行之前，你不知道x 和 y 的值是什么，只有函数实际被执行，被调用，在函数内，你才知道形参的实际数值是什么。

摘自[知乎 酷python](https://zhuanlan.zhihu.com/p/291202430)

## Two types of argument passing
在传递函数的时候，实参和形参之间有着不同的联系，它们之间的联系取决于形参的类型。如果形参是引用（reference）那么形参和实参之间有着被绑定的关系，否则实参只是形参的一个拷贝。

## Section 6.2.1 Passing Arguments by Value
当一个非引用类型的变量（nonreference type variable）被初始化之后，其变量的值是被拷贝过来的。

```cpp
int n = 0;
int i = n; // i是n的一个拷贝
i = 2; // 给i重新赋值
std::cout << i << std::endl; // i的结果是2
```
用这种方式传递实参效果是一样的，函数对实参进行了一次拷贝，再函数被调用的生命周期中，实参并不会被函数影响或改变。
